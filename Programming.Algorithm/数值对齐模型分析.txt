
在C语言开发中，经常会遇到一些内存地址对齐的操作，如下的宏,要求指针B,P都是char *类型，
A必须是二制数值是全1的数;

#define __BPTR_ALIGN(B, P, A) ((B) + (((P) - (B) + (A)) & ~(A)))
应用实例：
假设B=0x00110000, P=0x00110111, A=0x11
则 __BPTR_ALIGN(B, P, A) = 0x00111000 = B + 0x1000 = B + 8
分析： P - B = 7 = 0x111，A是0x11，表示P的地址值必须是4的倍数(0, 4, 8, 12, 16, ...)， 
       所以 4 < 7 < 8，而这个宏又是向上取整，所以是 8，而不是4.

这个宏是基于什么数学原理设计的模型呢？
(offset + A) & ~A 就可以得到向上取整的数

因为A是n位全1的数，如果offset的低n位，只要其中至少有一位是1，那么就会意味着这个
offset + A的表达式的值会向n + 1位进1位，进1位的值刚好是多了2的n次方
所以A=3，如果导致进位，就是会加4
如果A=7，如果导致进位，就是会加8
依此类推...

如果向下取整，那相当简单，只要将差值的低n位都置0就OK了.
P - B & ~A
